// import emoji from "../../../assets/kusty.png";

const rotate_icon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.42871 5.13485V10.2777M3.42871 10.2777H8.57157M3.42871 10.2777L7.40585 6.54057C8.58949 5.35893 10.1251 4.59397 11.7813 4.36095C13.4375 4.12794 15.1245 4.43948 16.5883 5.24865C18.052 6.05782 19.2131 7.32078 19.8967 8.84722C20.5802 10.3737 20.7492 12.0809 20.378 13.7117C20.0069 15.3425 19.1159 16.8086 17.8391 17.8889C16.5623 18.9693 14.9691 19.6054 13.2993 19.7015C11.6296 19.7976 9.97383 19.3485 8.58156 18.4217C7.18928 17.495 6.13591 16.1409 5.58014 14.5634" stroke="#8217FF" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;
const copy_icon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.00014 14.5714H5.143C4.68834 14.5714 4.2523 14.3908 3.93081 14.0693C3.60932 13.7478 3.42871 13.3118 3.42871 12.8571V5.14284C3.42871 4.68819 3.60932 4.25215 3.93081 3.93066C4.2523 3.60917 4.68834 3.42856 5.143 3.42856H12.8573C13.3119 3.42856 13.748 3.60917 14.0695 3.93066C14.391 4.25215 14.5716 4.68819 14.5716 5.14284V5.99999M11.143 9.42856H18.8573C19.8041 9.42856 20.5716 10.1961 20.5716 11.1428V18.8571C20.5716 19.8039 19.8041 20.5714 18.8573 20.5714H11.143C10.1962 20.5714 9.42871 19.8039 9.42871 18.8571V11.1428C9.42871 10.1961 10.1962 9.42856 11.143 9.42856Z" stroke="#8217FF" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;
const thumbs_up_icon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.71442 20.5714H5.143C4.68834 20.5714 4.2523 20.3908 3.93081 20.0693C3.60932 19.7478 3.42871 19.3118 3.42871 18.8571V12.8571C3.42871 12.4025 3.60932 11.9664 3.93081 11.6449C4.2523 11.3235 4.68834 11.1428 5.143 11.1428H7.71442M13.7144 9.42856V5.99999C13.7144 5.318 13.4435 4.66395 12.9613 4.18171C12.479 3.69948 11.825 3.42856 11.143 3.42856L7.71442 11.1428V20.5714H17.383C17.7964 20.5761 18.1976 20.4312 18.5126 20.1634C18.8277 19.8957 19.0353 19.523 19.0973 19.1143L20.2801 11.4C20.3174 11.1543 20.3009 10.9034 20.2316 10.6648C20.1623 10.4261 20.0419 10.2054 19.8789 10.0179C19.7158 9.83033 19.5139 9.6805 19.2872 9.57874C19.0605 9.47699 18.8143 9.42574 18.5659 9.42856H13.7144Z" stroke="#8217FF" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;
const thumbs_down_icon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.71442 3.42858H5.143C4.68834 3.42858 4.2523 3.6092 3.93081 3.93069C3.60932 4.25218 3.42871 4.68821 3.42871 5.14287V11.1429C3.42871 11.5975 3.60932 12.0336 3.93081 12.3551C4.2523 12.6765 4.68834 12.8572 5.143 12.8572H7.71442M13.7144 14.5714V18C13.7144 18.682 13.4435 19.3361 12.9613 19.8183C12.479 20.3005 11.825 20.5714 11.143 20.5714L7.71442 12.8572V3.42858H17.383C17.7964 3.42391 18.1976 3.56881 18.5126 3.83658C18.8277 4.10435 19.0353 4.47695 19.0973 4.88573L20.2801 12.6C20.3174 12.8457 20.3009 13.0966 20.2316 13.3352C20.1623 13.5739 20.0419 13.7946 19.8789 13.9821C19.7158 14.1697 19.5139 14.3195 19.2872 14.4213C19.0605 14.523 18.8143 14.5743 18.5659 14.5714H13.7144Z" stroke="#8217FF" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;
const magic_icon = `<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.75 2.25V5.25M2.25 3.75H5.25M4.5 12.75V15.75M3 14.25H6M9.75 2.25L11.4643 7.39286L15.75 9L11.4643 10.6071L9.75 15.75L8.03571 10.6071L3.75 9L8.03571 7.39286L9.75 2.25Z" stroke="#8217FF" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;

const pre_magic_icon = `<svg width="34" height="34" viewBox="0 0 34 34" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="0.5" y="0.5" width="33" height="33" rx="3.5" fill="#F3E8FF"/>
<rect x="0.5" y="0.5" width="33" height="33" rx="3.5" stroke="#C694FF"/>
<path d="M11.75 10.25V13.25M10.25 11.75H13.25M12.5 20.75V23.75M11 22.25H14M17.75 10.25L19.4643 15.3929L23.75 17L19.4643 18.6071L17.75 23.75L16.0357 18.6071L11.75 17L16.0357 15.3929L17.75 10.25Z" stroke="#8217FF" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;

const templates_icon = `<svg width="22" height="20" viewBox="0 0 22 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10.049 1.92664C10.3483 1.00537 11.6517 1.00538 11.951 1.92664L13.4699 6.60055C13.6038 7.01254 13.9877 7.29148 14.4209 7.29149L19.3354 7.29168C20.3041 7.29172 20.7068 8.53127 19.9232 9.10067L15.9474 11.9895C15.5969 12.2441 15.4503 12.6955 15.5841 13.1075L17.1026 17.7815C17.4019 18.7028 16.3475 19.4689 15.5638 18.8995L11.5878 16.011C11.2373 15.7564 10.7627 15.7564 10.4122 16.011L6.43622 18.8995C5.65252 19.4689 4.5981 18.7028 4.8974 17.7815L6.41589 13.1075C6.54974 12.6955 6.40309 12.2441 6.05263 11.9895L2.07683 9.10067C1.29317 8.53127 1.69592 7.29172 2.66461 7.29168L7.57911 7.29149C8.01231 7.29148 8.39623 7.01254 8.53011 6.60055L10.049 1.92664Z" stroke="#282829" stroke-width="1.5"/>
</svg>
`;

const custom_prompt_icon = `<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 3H3C1.89543 3 1 3.89543 1 5V16C1 17.1046 1.89543 18 3 18H14C15.1046 18 16 17.1046 16 16V11M14.5858 1.58579C15.3668 0.804738 16.6332 0.804738 17.4142 1.58579C18.1953 2.36683 18.1953 3.63316 17.4142 4.41421L8.82842 13H6L6 10.1716L14.5858 1.58579Z" stroke="#282829" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;

const liked_thumbs_up = `<svg width="24" height="24" viewBox="0 0 24 24" fill="#8217FF" xmlns="http://www.w3.org/2000/svg">
<path d="M7.71442 20.5714H5.143C4.68834 20.5714 4.2523 20.3908 3.93081 20.0693C3.60932 19.7478 3.42871 19.3118 3.42871 18.8571V12.8571C3.42871 12.4025 3.60932 11.9664 3.93081 11.6449C4.2523 11.3235 4.68834 11.1428 5.143 11.1428H7.71442M13.7144 9.42856V5.99999C13.7144 5.318 13.4435 4.66395 12.9613 4.18171C12.479 3.69948 11.825 3.42856 11.143 3.42856L7.71442 11.1428V20.5714H17.383C17.7964 20.5761 18.1976 20.4312 18.5126 20.1634C18.8277 19.8957 19.0353 19.523 19.0973 19.1143L20.2801 11.4C20.3174 11.1543 20.3009 10.9034 20.2316 10.6648C20.1623 10.4261 20.0419 10.2054 19.8789 10.0179C19.7158 9.83033 19.5139 9.6805 19.2872 9.57874C19.0605 9.47699 18.8143 9.42574 18.5659 9.42856H13.7144Z" stroke="#8217FF" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;

const disliked_thumbs_down = `<svg width="24" height="24" viewBox="0 0 24 24" fill="#8217FF" xmlns="http://www.w3.org/2000/svg">
<path d="M7.71442 3.42858H5.143C4.68834 3.42858 4.2523 3.6092 3.93081 3.93069C3.60932 4.25218 3.42871 4.68821 3.42871 5.14287V11.1429C3.42871 11.5975 3.60932 12.0336 3.93081 12.3551C4.2523 12.6765 4.68834 12.8572 5.143 12.8572H7.71442M13.7144 14.5714V18C13.7144 18.682 13.4435 19.3361 12.9613 19.8183C12.479 20.3005 11.825 20.5714 11.143 20.5714L7.71442 12.8572V3.42858H17.383C17.7964 3.42391 18.1976 3.56881 18.5126 3.83658C18.8277 4.10435 19.0353 4.47695 19.0973 4.88573L20.2801 12.6C20.3174 12.8457 20.3009 13.0966 20.2316 13.3352C20.1623 13.5739 20.0419 13.7946 19.8789 13.9821C19.7158 14.1697 19.5139 14.3195 19.2872 14.4213C19.0605 14.523 18.8143 14.5743 18.5659 14.5714H13.7144Z" stroke="#8217FF" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`;


let styledData = `
  .actionBtn{
    width:100%;
    height: 40px;
    color:white;
  }
    
  .actionBtn:hover{
    background-color: pink !important;
  }

  .loader {
    border: 3px solid #f3f3f3;
    border-radius: 50%;
    border-top: 3px dashed rgb(255, 255, 255);
    border-right: 3px dashed rgb(255, 255, 255);
    border-bottom: 3px dashed rgb(255, 255, 255);
    border-left: 3px dashed rgb(255, 255, 255);
    width: 20px;
    height: 20px;
    -webkit-animation: spin 2s linear infinite;
    animation: spin 2s linear infinite;
  }

  .response-box {
    position: relative;
    margin: 10px 0px;
    border: 1px solid;
    background: #D3D3D3;
    text-align: justify;
    cursor: pointer;
    padding: 7px 10px;
    background: #FFFFFF;
    border: 1px solid #B3B3B3;
    border-radius: 8px;
    color: #282829;
    font-family: "poppins";
    font-weight: 400;
    font-size: 13px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: background-color 0.2s ease-in-out;
  }

  .response-box:hover {
    background-color: #ebebeb;
  }

  .loader-prompt {
    border: 3px solid #000000;
    border-radius: 50%;
    border-top: 3px dashed #000000;
    border-right: 3px dashed #000000;
    border-bottom: 3px dashed #000000;
    border-left: 3px dashed #000000;
    width: 16px;
    height: 16px;
    -webkit-animation: spin 2s linear infinite;
    animation: spin 2s linear infinite;
  }

  .copied-message {
    position: absolute;
    top: -20px;
    right: 151px;
    background-color: #005EFF;
    color: white;
    padding: 4px 8px;
    font-size: 12px;
    font-family: "poppins";
    border-radius: 5px;
    animation: fadeOut 2s forwards;
  }

  @keyframes fadeOut {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }

  @-webkit-keyframes spin {
    0% { -webkit-transform: rotate(0deg); }
    100% { -webkit-transform: rotate(360deg); }
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .write_paste_selected_txt {       
        padding: 8px 16px 8px 16px;
        border-radius: 56px;
        text-align: center;
        margin: 10px 25px 5px;
        font-family: poppins;
        font-weight: 500;
    }
    
    .write_paste_selected_txt,
    .active_comp {
        color: #8217FF;
        background: #F3E8FF;
        border: 1px solid #F3E8FF;
    }

    .post_shortcut_list {
        display: flex;
        flex-direction: column;
        border: 1px solid #C694FF;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 500;
        font-family: poppins;
        background: #FFFFFF;
    }

    .preShortcutLoadingv {
        background: #F6F6F6;
        padding: 5px;
        margin: 10px 0px;
        width: 100%;
    }

    .pre_shortcut_list {
        display: flex;
        flex-direction: column;
        border: 1px solid #C694FF;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 600;
        font-family: poppins;
        background: #FFFFFF;
        width: 72%;
        margin: 5px auto;
    }

    .ps_single_item {
        border-bottom: 1px solid #F2F2F2;
        display: flex;
        padding: 12px 6px;
        justify-content: space-between;
        align-items: center;
        cursor: default;
    }

    .ps_single_item:first-child {
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
    }

    .ps_single_item:last-child {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
    }

    .ps_single_item:hover {
        border-bottom: 1px solid #F2F2F2;
        display: flex;
        padding: 12px 7px;
        justify-content: space-between;
        align-items: center;
        background-color: #F3E8FF;
    }

    .pr_single_item {
        border-bottom: 1px solid #F2F2F2;
        display: flex;
        padding: 12px 6px;
        align-items: center;
        cursor: default;
        gap: 10px;
    }

    .pr_single_item:first-child {
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
    }

    .pr_single_item:last-child {
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
    }

    .pr_single_item:hover {
        border-bottom: 1px solid #F2F2F2;
        display: flex;
        padding: 12px 7px;
        align-items: center;
        background-color: #F3E8FF;
    }

    .post_shortcut_subcategory {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .ps_subcategory_item {
        color: #282829;
        font-weight: 500;
        border: 1px solid #282829;
        border-radius: 16px;
        padding: 4px 8px;
    }

    .ps_subcategory_item:hover {
        color: #8217FF;
        font-weight: 500;
        border: 1px solid #8217FF;
        border-radius: 16px;
        padding: 4px 8px;
    }

    .ps_main_list_names {
        color: #282829
    }

    .pre_ta_parent {
        background: #F9FAFB;
        border-radius: 8px;
        display: inline-flex;
        width: 95%;
        border: 1px solid #E6E6E6;
        overflow: hidden;
        margin: 8px 8px;
    }

    .pre_textarea {
        width: 100%;
        display: flex;
    }

    .textarea_input {
        padding: 10px;
        height: 74px;
        width: 100%;
        outline: none;
        border: none;
        resize: none;
        border-radius: 8px;
        background: #F9FAFB;
    }

    .textarea_input::placeholder {
        color: #B3B3B3;
        font-size: 12px;
    }

    .magic_icon {
        padding: 10px;
    }

    .selected_txt_post_blog {
        display: flex;
        flex-direction: column;
        gap: 20px;
        background: #F6F6F6;
        padding: 10px;
    }

    .st_response {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 0px 10px;
        font-size: 14px;
        font-family: poppins;
        color: #282829;
        font-weight: 500;
    }

    .select_text_heading {
        color: #8217FF;
        background: #F3E8FF;
        width: 40%;
        padding: 4px;
        border-radius: 4px;
        /*text-align: center;*/
    }

    .query {
        text-align: justify;
    }

    .overall_icon_pack {
        font-size: 14px;
        font-family: poppins;
        font-weight: 500;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 15px 10px 10px;
    } 

    .action_items {
        color: #8217FF;
        background: #F3E8FF;
        /*width: 66%;*/
        padding: 6px;
        border-radius: 4px;
        /*text-align: center;*/
    }

    .ac_content {
        text-align: justify;
        padding: 0 5px;
        white-space: pre-wrap; 
    }

    .iconItems {
        display: flex;
        gap: 10px;
        cursor: pointer;
        align-items: center;
        padding: 0px 5px;
    }

    .postShortcutLoadingv {
        background: #F6F6F6;
        margin: 10px 0px;
        padding: 5px;
    }

    .copy_data {
        position: relative;
    }

    .copied-message-ai {
        background: black;
        color: white;
        padding: 1.5px 5px;
        position: absolute;
        bottom: 30px;
        left: -11px;
        border-radius: 4px;
        font-size: 12px;
        font-family: poppins;
        text-align: center;        
        animation: fadeOut 2s forwards;
    }

    .selected_pre_option {
        display: flex;
        /* gap: 7px; */
        justify-content: space-between;
        background: red;
        padding: 8px 15px;
        margin: 0px 10px;
        border-radius: 8px;
        background: #F3E8FF;
        color: #282829;
        font-weight: 500;
        font-family: poppins;
        align-items: center;
    }

    .spinner_bounce > div {
        width: 10px;
        height: 10px;
        background-color: #333;
        border-radius: 100%;
        display: inline-block;
        -webkit-animation: bounceDelay 1.4s infinite ease-in-out both;
        animation: bounceDelay 1.4s infinite ease-in-out both;
    }

    .spinner_bounce .bounce1 {
        -webkit-animation-delay: -0.32s;
        animation-delay: -0.32s;
    }

    .spinner_bounce .bounce2 {
        -webkit-animation-delay: -0.16s;
        animation-delay: -0.16s;
    }

    @-webkit-keyframes bounceDelay {
        0%,
        80%,
        100% {
            -webkit-transform: scale(0);
        }
        40% {
            -webkit-transform: scale(1);
        }
    }

    @keyframes bounceDelay {
        0%,
        80%,
        100% {
            -webkit-transform: scale(0);
            transform: scale(0);
        }
        40% {
            -webkit-transform: scale(1);
            transform: scale(1);
        }
    }

    .latest_AI_types {
        display: flex;
        justify-content: space-between;
        padding: 5px;
        align-items: center;
        font-family: "poppins";
        font-size: 16px;
        gap: 10px;
    }

    .new_non_selected_prompts {
        border: 1px solid #CCCCCC;
        border-radius: 30px;
        background: #F9FAFB;
        width: 106px;
        height: 32px;
        text-align: center;
        padding: 6px 12px;
        color: #282829;
        font-weight: 500;
        cursor: pointer;
    }

    .new_non_selected_prompts:hover {
        border: 1px solid #8217FF;
        border-radius: 30px;
        background: #F3E8FF;
        width: 106px;
        height: 32px;
        text-align: center;
        padding: 6px 12px;
        color: #282829;
        font-weight: 500;
        cursor: pointer;
    }

    .new_selected_prompts {
        border: 1px solid #8217FF;
        border-radius: 30px;
        background: #F3E8FF;
        width: 106px;
        height: 32px;
        text-align: center;
        padding: 6px 12px;
        color: #282829;
        font-weight: 500;
        cursor: pointer;
    }

    .notAllowed {
        cursor: not-allowed;
    }

    .promptoWritingStyleOptions {
        display: flex;
        justify-content: space-between;
        width: 300px;
        margin: 10px;
        font-size: 14px;
        font-weight: 500;
        font-family: poppins;
    }

    .tone_style_content {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .tone_lists {
        width: 140px;
        height: 34px;
        border-radius: 4px;
    }

    .new_non_selected_prompts_notAllowed {
        border: 1px solid #CCCCCC;
        border-radius: 30px;
        background: #F9FAFB;
        width: 106px;
        height: 32px;
        text-align: center;
        padding: 6px 12px;
        color: #282829;
        font-weight: 500;
        cursor: not-allowed;
    }

`
let styleSection = `\`${styledData}\``;
let instance_key = process.env.x_Dev_apiKey;
let instance_t = process.env.x_Dev_apitoken;
let client_id = process.env.Dev_CF_ACCESS_CLIENT_ID;
let client_sec = process.env.Dev_CF_ACCESS_CLIENT_SECRET;

export default {
    name: "sample_authorai",
    // template: "<div>Hello AuthorAI Application!</div>",
    template: `
        if (appSettings && appSettings.default) {
            const { useState, useEffect, useRef } = React;   

            const createPayload = (module, action) => {
                return [
                {
                    module: module,
                    event: action,
                },
                ];
            };

            let instance_key = "${instance_key}";
            let instance_t = "${instance_t}";
            let client_id = "${client_id}";
            let client_sec = "${client_sec}";

            let dev_headers = {
                "x-apikey": "${instance_key}",
                "x-apitoken": "${instance_t}",
                "CF-ACCESS-CLIENT-ID": "${client_id}",
                "CF-ACCESS-CLIENT-SECRET": "${client_sec}"
            }            
                
            async function logsAPI({ isAuthuu, setting_token, user_setting, PAYLOAD_FOR_EVENT, UUID = null, log_message = null }) {
                let app_version = "1.0.0"
                try {
                let endpoint = '/v1/commands/' + isAuthuu.appId + '.app.logs_api_data/run'
                let auth = 'Bearer' + " " + setting_token;
                await KustomerRequest({
                    url: endpoint,
                    method: 'POST',
                    body: {
                    "headers": {
                        "Authorization": auth,
                        "Content-Type": "application/json",
                        "CF-ACCESS-CLIENT-ID":"57cf23a5470bb331979b5353e2205b25.access",
                        "CF-ACCESS-CLIENT-SECRET":"ca8fe3e2ae9569d1944b09e583a7dd5a181359dc3f18d2f1c3814225f1f76813"
                    },
                    "body": {
                        "user_email": user_setting.email,
                        "applicationName": "PromptoGPT",
                        "event_list": PAYLOAD_FOR_EVENT,
                        "user_id": user_setting.user_id,
                        "app_id": user_setting.app_id,
                        "app_name": "PromptoGPT",
                        "campaign_name": user_setting.campaign_name,
                        "campaign_id": user_setting.campaign_id,
                        "lob_id": user_setting.lob_id,
                        "lob_name": user_setting.lob_name,
                        "currentUserAppVersion": app_version,
                        "uuid": UUID,
                        "log_message": log_message
                    }
                    }
                },
                    (err, response) => {
                    if (err) {
                        console.log("Into 1")
                        return 'Failed to process return'
                    } else if (response.responseBody.errors) {
                        console.log("Into 2")
                        return response.responseBody.errors.message;
                    }
                    }
                );
                } catch (error) {
                console.log("Error in logsAPI::", error);
                }
            }

            const AuthorAIComponent = window.__authorAIComponent12345 || (window.__authorAIComponent12345 =
                function AuthorAIComponent(props) {
                    const {
                    conversation,
                    appSettings
                    } = props;

                    const [isLoggedStatus, setLoggedStatus] = useState(sessionStorage.getItem('authorAILoggedIn') === 'true');
                    const [isSettingStatus, setSettingStatus] = useState(sessionStorage.getItem('authorAIStatus') === 'true');
                    const [name, changeName] = useState('');
                    const [ischeckboxType, setCheckboxType] = useState('');
                    const [isLoading, setLoading] = useState(false);
                    const [prompt_res, setPrompt_res] = useState(null);
                    const [isApiCall, setApiCall] = useState(true);
                    const [generateToken, setGenerateToken] = useState({});
                    const [conv_id, setConv_id] = useState('');
                    const [isEmail, setEmail] = useState('');
                    const [isAuthuu, setAuthuu] = useState({});
                    const[lastUserRes, setLastUserRes] = useState('');
                    const[settingreg, setSettingreg] = useState({});
                    const [isAutoLoading, setAutoLoading] = useState(false);
                    const [copied, setCopied] = useState(null);
                    const [channelType, setChannelType] = useState(null);                
                    const [selectedText, setSelectedText] = useState('');
                    const [isSelecting, setSelecting] = useState(false);
                    const [postShortcutLoading, setPostShortcutLoading] = useState(false);
                    const [textArea, setTextArea] = useState('');
                    const [postpreConfig, setPostpreConfig] = useState({});
                    const [selections, setSelections] = useState([]);
                    const scrollRef = useRef(null);  // Ref to handle automatic scroll
                    const [postOrPreOnloading, setPostOrPreOnloading] = useState({
                        postOnloading: false,
                        preOnloading: false,
                        textData: ""
                    });
                    const [preShortcuts, setPreShortcuts] = useState({
                        preOnloading: false,
                        preShortcutOption: "",
                        dropdownOptions: {},
                        subDropdownOptions: {},
                        temp_json: {}
                    });
                    const [likedState, setLikedState] = useState({});
                    const [dislikedState, setDislikedState] = useState({});
                    const [user_setting_state, setUser_setting_state] = useState({
                        refreshToken: "",
                        settingResponse: {},
                        setting_token: ""
                    });
                    const [promptoRes, setPromptoRes] = useState({});
                    const [toneWriting, setToneWriting] = useState({
                        selected_tone: "soft", // Default value for tone
                        selected_writing_style: "professional"
                    });

                    function generateUUID() {
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                            const r = (Math.random() * 16) | 0;
                            const v = c === 'x' ? r : (r & 0x3) | 0x8;
                            return v.toString(16);
                        });
                    }

                    async function getDevTemplateList() {
                        let endpoint = "https://dev.democenter.app.taskus.com/api/external/getTemplateList/1";
                        try {                    
                            let response = await fetch(endpoint, {
                                method: "POST",
                                headers: {
                                    "authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6OTc3LCJ1c2VyX25hbWUiOiJzYW5nZWV0aGEueWVzdXJhamFuQHRhc2t1cy5jb20iLCJlbWFpbCI6InNhbmdlZXRoYS55ZXN1cmFqYW5AdGFza3VzLmNvbSIsIm5hbWUiOiJTYW5nZWV0aGEgWWVzdXJhamFuIiwic3RhdHVzIjp0cnVlLCJpc19zdXBlckFkbWluIjpmYWxzZSwiaWF0IjoxNzI5MTQyODk4LCJleHAiOjE3MjkxNDg1OTh9.SlLP9c32ICMCvpw1OLNDuowv5tEPUHSSSRTUUZV_HFA",
                                    "content-type": "application/json",
                                    "CF-Access-Client-Id": "a83be8f826ef30e595183ba6389029b6.access",
                                    "CF-Access-Client-Secret": "358e9d16fb4c93bcc63d2b78d4f4c5e03ece2d07e5d6a5a82b85d58c77e5ec27"
                                },                        
                                // mode: 'no-cors',
                                body: JSON.stringify({
                                    "page": 1,
                                    "take": 10,
                                    "searchBy": "",
                                    "filterBy": ""
                                })
                            });

                            if (!(response.ok)) {
                                throw new Error('Http error status', response?.status, response);
                            } 
                            let templateListData = await response.json();
                        } catch (err) {
                            console.log("Error in getTemplateList::", err);
                        }
                    }

                    //generate Auth Token API
                    async function generateTokenApi(user_setting_response, emailId, isAuthuu) {
                        try {
                        const model_type = user_setting_response.settings.Zendesk_PromptoGPT_modeltype;
                        const usecase = user_setting_response.settings.Zendesk_PromptoGPT_usecase;

                        const promptoGPT_toggle = user_setting_response.settings.Zendesk_PromptoGPT_toggle;
                        const knowledgeAssist_toggle = user_setting_response.settings.Zendesk_KnowledgeAssist_toggle;
                        const authorAI_toggle = user_setting_response.settings.Kustomer_AuthorAI;

                        const apitoken = user_setting_response?.settings.x_apitoken;
                        const apikey = user_setting_response?.settings.x_apikey;
                        let endpoint = '/v1/commands/' + isAuthuu.appId + '.app.generate_authtoken_api_data/run';
                        let authResponse = await KustomerRequest({
                            url: endpoint,
                            method: 'POST',
                            body: {
                                "headers": {
                                    "Content-Type": "application/json",
                                    "x-apitoken": apitoken,
                                    "x-apikey": apikey,
                                    "CF-Access-Client-Id": user_setting_response?.settings.CF_Access_Client_Id,
                                    "CF-Access-Client-Secret": user_setting_response?.settings.CF_Access_Client_Secret
                                },
                                // headers: dev_headers,
                                "body": {
                                    "email": emailId
                                }
                            }
                        },
                            (err, response) => {
                            if (err) {
                                console.log("Into 1")
                                return 'Failed to process return'
                            } else if (response.responseBody.errors) {
                                console.log("Into 2")
                                return response.responseBody.errors.message;
                            }
                            }
                        );
                        const data = authResponse?.data?.attributes?.responseBody;
                        const authToken = data.authToken;
                        const clientAuthToken = data.clientAuthToken;
                        const authorAIInstance = data?.authorAIInstances
                        setLoading(false);
                        setSettingStatus(true);
                        return { authToken, clientAuthToken, model_type, usecase, promptoGPT_toggle, knowledgeAssist_toggle, authorAI_toggle, authorAIInstance }
                        } catch (err) {
                        console.log("Error in generateTokenApi::", err);
                        }
                    }  

                    // Handle like click
                    const handleLikeClick = async (index, selectionDataItem) => {
                        setLikedState(prevState => ({
                            ...prevState,
                            [index]: !prevState[index] // Toggle like state for the specific item
                        }));

                        setDislikedState(prevState => ({
                            ...prevState,
                            [index]: false // Ensure the corresponding dislike is reset for the same item
                        }));

                        let unique_uuid = generateUUID();
                        const log_payload = createPayload(
                            'Kustomer_AuthorAI_clicked_star_rating',
                            'Success'
                        );
                        let thumbs_up_msg = "Rating: Thumbs up API response: " + " " + selectionDataItem?.originalData;
                        await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, UUID: unique_uuid, log_message: thumbs_up_msg });
                    }

                    // Handle dislike click
                    const handleDislikeClick = async (index, selectionDataItem) => {
                        setDislikedState(prevState => ({
                            ...prevState,
                            [index]: !prevState[index] // Toggle dislike state for the specific item
                        }));

                        setLikedState(prevState => ({
                            ...prevState,
                            [index]: false // Ensure the corresponding like is reset for the same item
                        }));

                        let unique_uuid = generateUUID();
                        const log_payload = createPayload(
                            'Kustomer_AuthorAI_clicked_star_rating',
                            'Success'
                        );
                        let thumbs_down_msg = "Rating: Thumbs down API response: " + " " + selectionDataItem?.originalData;
                        await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, UUID: unique_uuid, log_message: thumbs_down_msg });
                    };

                    const promptoApi = async () => {
                        try {
                            let endpoint = '/v1/commands/' + isAuthuu.appId + '.app.promptogpt/run';
                            let setting_token = "Bearer" + " " + settingreg?.setting_token;
                            let prompRes = await KustomerRequest({
                                url: endpoint,
                                method: "POST",
                                body: {
                                    "headers": {
                                        "authorization": setting_token
                                    },
                                    "body": {
                                        "appName": "PromptoGPT",
                                        "page": 1,
                                        "take": 10,
                                        "searchCriterias": [
                                            {
                                                "criteriaName": "CATEGORY",
                                                "value": ""
                                            }
                                        ],
                                        "email": isEmail
                                    }
                                }
                            }, (err, res) => {
                                if (err) {
                                    return 'Failed to process return'
                                } else if (response.responseBody.errors) {
                                    return response.responseBody.errors.message;
                                }
                            }
                            );
                            if (prompRes?.data?.attributes?.responseBody) {
                                setPreShortcuts({
                                    ...preShortcuts,
                                    temp_json: prompRes?.data?.attributes?.responseBody?.data[0]?.jsonValue
                                })
                                return prompRes?.data?.attributes?.responseBody;
                            }
                        } catch (err) {
                            console.log("Error in promptoApi::", err)
                        }
                    }

                    const highlightHeadings = (text) => {
                        // Ensure the input is a string
                        if (typeof text !== 'string') {
                            
                            return null; // Or return an empty fragment
                        }

                        return text.split(" ").map((e, index) => {
                            if (e.match(/[a-zA-Z]+:/)) {
                                // Return a bolded span element for headings
                                return <span key={index} style={{ fontWeight: "bold" }}>{e} </span>;
                            } else {
                                // Return the regular word in a span
                                return <span key={index}>{e} </span>;
                            }
                        });
                    };

                    //api's
                    async function postPreAutoSuggestApi(payload, isAuthuu) {
                        setAutoLoading(true);
                        let unique_uuid = generateUUID();
                        const log_payload = createPayload(
                            'Kustomer_AuthorAI_Request_Query_Started',
                            'Success'
                        );
                        let query_msg = "Query - " + payload.body?.question;
                        await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, UUID: unique_uuid, log_message: query_msg });

                        try {
                            let endpoint = '/v1/commands/' + isAuthuu.appId + '.app.auto_suggest_api_data/run';
                            let response = await KustomerRequest({
                                url: endpoint,
                                method: "POST",
                                body: {
                                    "headers": payload?.headers,
                                    "body": payload.body
                                }
                            },
                                (err, response) => {
                                    if (err) {
                                        console.log("Into 1")
                                        return 'Failed to process return'
                                    } else if (response.responseBody.errors) {
                                        console.log("Into 2")
                                        return response.responseBody.errors.message;
                                    }
                                }
                            );
                            if (response?.data?.attributes?.responseBody) {
                                let unique_uuid_complete = generateUUID();
                                const log_payload_completed = createPayload(
                                    'Kustomer_AuthorAI_Request_Query_Response_Generate_Completed',
                                    'Success'
                                );
                                let res_msg = "Received the API response - " + response?.data?.attributes?.responseBody?.answer;
                                await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload_completed, UUID: unique_uuid_complete, log_message: res_msg });
                                
                                setAutoLoading(false);
                                setSelectedText('');
                                setTextArea('');
                                setPreShortcuts({
                                    ...preShortcuts,
                                    preOnloading: false,
                                    preShortcutOption: ""
                                });
                                let formattedResponseData;
                                if (payload?.body?.usecase == "summarize" || payload?.body?.usecase == "fix_spelling_grammar" || payload?.body?.usecase == "helping_pronunce") {
                                    formattedResponseData = highlightHeadings(response?.data?.attributes?.responseBody?.answer);
                                } else {
                                    formattedResponseData = response?.data?.attributes?.responseBody?.answer;
                                }
                                // let useCaseOption = findUseCaseOption(response?.data?.attributes?.responseBody);
                                setPostpreConfig({
                                    ...postpreConfig,
                                    // postpreResponse: responseData
                                    postpreResponse: formattedResponseData
                                });
                                setToneWriting({
                                    selected_tone: "soft", // Default value for tone
                                    selected_writing_style: "professional"
                                });
                                setPostOrPreOnloading({ ...postOrPreOnloading, textData: payload.body?.question })
                                let originalData = response?.data?.attributes?.responseBody?.answer;
                                let showText = payload.body?.question;
                                let res_useCase_option = {
                                    usecase: payload?.body?.usecase,
                                    useCaseOption: payload?.body?.usecase_options
                                }
                                let category = payload?.category;
                                setSelections((prevSelections) => [
                                    ...prevSelections,
                                    { showText, formattedResponseData, originalData, res_useCase_option, category }
                                ]);
                                return response?.data?.attributes?.responseBody;
                            }
                        } catch (error) {
                            console.log("Error in postPreAutoSuggestApi::", error)
                        }
                    }

                    async function autoSuggestApi(user_email, latestmsgfromuser, model_type, use_case, auth_token, isAuthuu, user_setting_infos, setting_token) {
                        setAutoLoading(true);
                        let unique_uuid = generateUUID();
                        const payload = createPayload(
                            'Kustomer_PromptoGPT_Request_Query_Started',
                            'Success'
                        );
                        await logsAPI({isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: user_setting_infos, PAYLOAD_FOR_EVENT: payload, UUID: unique_uuid });
                        try {
                            let endpoint = '/v1/commands/' + isAuthuu.appId + '.app.auto_suggest_api_data/run';
                            let response = await KustomerRequest({
                            url: endpoint,
                            method: "POST",
                            body: {
                                "headers": {
                                    "Content-Type": "application/json",
                                    "X-Authtoken": auth_token,
                                    "CF-ACCESS-CLIENT-ID": settingreg?.CF_Access_Client_Id,
                                    "CF-ACCESS-CLIENT-SECRET": settingreg?.CF_Access_Client_Secret
                                },
                                "body": {
                                    "user_id": user_email,
                                    "question": latestmsgfromuser,
                                    "model_type": model_type.toLowerCase(),
                                    "usecase": use_case.toLowerCase(),
                                    "enable_automasking": true
                                }
                            }
                            },
                            (err, response) => {
                                if (err) {
                                    console.log("Into 1")
                                    return 'Failed to process return'
                                } else if (response.responseBody.errors) {
                                    console.log("Into 2")
                                    return response.responseBody.errors.message;
                                }
                            }
                            );
                            if (response?.data?.attributes?.responseBody) {
                                let unique_uuid = generateUUID();
                                const payload = createPayload(
                                    'Kustomer_PromptoGPT_Request_Query_Completed',
                                    'Success'
                                );
                                await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: user_setting_infos, PAYLOAD_FOR_EVENT: payload, UUID: unique_uuid });
                                const payload_query = createPayload(
                                    'Kustomer_PromptoGPT_Request_Query',
                                    'Success'
                                );
                                let unique_uuid_query = generateUUID();
                                await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: user_setting_infos, PAYLOAD_FOR_EVENT: payload_query, UUID: unique_uuid_query, log_message: latestmsgfromuser });
                                setAutoLoading(false);
                                return response?.data?.attributes?.responseBody;
                            }

                        } catch (error) {
                            console.log("Error in autoSuggestApi::", error)
                        }
                    }

                    useEffect(() => {
                        let updatedAuth = {};
                        (appSettings?.default || []).forEach((item) => {
                            if (item.attributes.name === 'apikey') {
                                updatedAuth.api_key = item.attributes.value;
                            }
                            if (item.attributes.name === 'authtoken') {
                                updatedAuth.authtoken = item.attributes.value;
                                updatedAuth.appId = item.attributes.app;
                            }
                            if (item.attributes.name === 'dev_normal_url') {
                                updatedAuth.url_def = item.attributes.value;
                                updatedAuth.appId = item.attributes.app;
                            }
                            if (item.attributes.name === 'dev_normal_url') {
                                updatedAuth.dev_normal_url = item.attributes.value;
                                updatedAuth.appId = item.attributes.app; 
                            }
                        });
                        setAuthuu(updatedAuth);
                    }, [appSettings?.default]);
                    
                    useEffect(() => {
                    }, [isAuthuu, prompt_res, settingreg, isAutoLoading, isEmail, channelType]);

                    useEffect(() => {
                        KustomerRequest({ url: '/v1/users/current' }).then(result => {
                            changeName(result.data.attributes.name);
                            setEmail(result.data.attributes.email);
                        });        
                        }, []);

                        useEffect(() => {
                        if (conversation) {
                            setConv_id(conversation?.id)
                        }
                        if (conv_id) {
                            // let api_token = 'Bearer'+" "+process.env.API_TOKEN          
                            let endpoint = '/v1/conversations/'+conv_id+'/messages';
                            KustomerRequest({ url: endpoint, method: "GET"}).then((result) => {
                            findLastResponse(result?.data)
                            })
                        }
                        if ((lastUserRes) && (conv_id) && (ischeckboxType == 'promptogpt')) {
                            // promptoGPTApi(isEmail, lastUserRes, generateToken?.model_type, generateToken?.usecase, generateToken?.authToken)
                            const autosuggestResponse = async () => {
                            try {
                                await showPromptRes(isEmail, lastUserRes, generateToken?.model_type, generateToken?.usecase, generateToken?.authToken)
                            } catch (err) {
                                console.log("Error in autosuggestResponse::", err);
                            }
                            }
                            autosuggestResponse();
                        }
                    }, [conversation, conv_id, generateToken, lastUserRes, ischeckboxType]);

                    useEffect(() => {
                        if ((isSettingStatus) && (isApiCall)) {
                            if (isEmail) {
                            // settingResponse();
                            settingBtnAPI()
                            }            
                        }
                    }, [isSettingStatus, isApiCall, isEmail]);

                    useEffect(() => {
                        if (generateToken) {
                        }       
                    }, [generateToken]);  

                    const refreshTokenApi = async (refresh_token) => {
                        try {
                            let endpoint = '/v1/commands/' + isAppId.appId + '.app.refresh_token/run';
                            let token = 'Bearer' + " " + refresh_token;
                            let refresh_res = await KustomerRequest({
                                url: endpoint,
                                method: "POST",
                                headers: {
                                    'Authorization': token,
                                    "Content-Type": "application/json",
                                    "CF-ACCESS-CLIENT-ID":"57cf23a5470bb331979b5353e2205b25.access",
                                    "CF-ACCESS-CLIENT-SECRET":"ca8fe3e2ae9569d1944b09e583a7dd5a181359dc3f18d2f1c3814225f1f76813"
                                }
                            },
                                (err, response) => {
                                    if (err) {
                                        console.log("Into refreshTokenApi Error ", err)
                                        return 'Failed to process return'
                                    } else if (response.responseBody.errors) {
                                        return response.responseBody.errors.message;
                                    }
                                }
                            );
                            if (refresh_res?.data?.attributes?.responseBody) {
                                return refresh_res?.data?.attributes?.responseBody;
                            }
                        } catch (err) {
                            console.log("Error in refreshTokenApi::", err);
                        }
                    }

                    useEffect(() => {
                        function healthCheckUp() {
                            try {
                                if (user_setting_state?.refreshToken) {
                                    exhealth().then(async (response) => {

                                    }).catch((error) => {
                                        if (error.message == "Invalid JWT Token") {
                                            refreshTokenApi(user_setting_state?.refreshToken)
                                                .then((res) => {
                                                    setUser_setting_state({
                                                        ...user_setting_state,
                                                        refreshToken: res?.refreshToken,
                                                        setting_token: res?.authToken
                                                    });
                                                    if (res?.authToken) return exhealth();
                                                }).catch((error) => {
                                                    handleSessionInvalidation(error);
                                                })
                                        }
                                    })
                                } 

                                function handleSessionInvalidation(error) {
                                    // const datum = sessionStorage.getItem('isLoggedIn');
                                    setTimeout(() => {
                                        setLoading(false);
                                        setSettingStatus(false);
                                    }, 5000);
                                    setLoading(false);
                                    sessionStorage.setItem('authorAILoggedIn', false);
                                    setLoggedStatus(false);
                                    setApiCall(false);
                                    sessionStorage.setItem('authorAIsettingStatus', false);
                                    setSettingStatus(false);

                                    throw error;
                                }

                            } catch (error) {
                                console.log("Error in healthCheckUp::", error)
                            }
                        }

                        const intervalId = setInterval(() => {
                            // healthCheckUp()
                        }, 5000)

                        // Clear the interval when the component is unmounted or when isRefreshToken changes
                        return () => clearInterval(intervalId);

                    }, [settingreg?.refreshToken])

                    useEffect(() => {
                        const dataPrompt = async () => {
                            try {
                                let promptResponse = await promptoApi();
                                setPromptoRes({
                                    promptToneOptions: promptResponse?.data[0]?.jsonValue?.tone,
                                    promptoWritingStyleOptions: promptResponse?.data[0]?.jsonValue?.writing_style,
                                    shownforTemplate: promptResponse?.data[0]?.jsonValue?.body
                                })
                               
                            } catch (err) {
                                console.log("Error in dataPrompt::", err);
                            }
                        }
                        if (settingreg?.setting_token) {
                            dataPrompt();
                        }

                    }, [settingreg?.setting_token])

                    useEffect(() => {

                        if (isLoggedStatus && isSettingStatus) {
                            let pendingClick = 0;

                            const handleSelection = () => {
                                const selection = window.getSelection();
                                const selectedText = selection.toString().trim();

                                if (selectedText.length > 0) {
                                    setSelectedText(selectedText);
                                    setSelecting(true);
                                    setPostShortcutLoading(false);
                                } else {
                                    // setSelecting(false);
                                }
                            };

                            const xorClick = (e) => {
                                // Clear any pending single-clicks if a new click is detected
                                if (pendingClick) {
                                    clearTimeout(pendingClick);
                                    pendingClick = 0;
                                }

                                switch (e.detail) {
                                    case 1:
                                        // Schedule single-click action if no double-click follows
                                        pendingClick = setTimeout(() => {
                                            // const selection = window.getSelection();
                                            // const selectedText = selection.toString().trim();

                                            // if (selectedText.length > 0) {
                                            //     setSelectedText(selectedText);
                                            //     setSelecting(true);
                                            //     console.log('Single click - text selected:', selectedText);
                                            // } else {
                                            //     setSelecting(false);
                                            // }
                                            console.log("Into this one Single")
                                            // setSelecting(true)
                                        }, 500); // Delay to wait for double-click
                                        break;

                                    case 2:
                                        // Immediately handle double-click action
                                        clearTimeout(pendingClick);
                                        const selection = window.getSelection();
                                        const selectedText = selection.toString().trim();
                                        setTextArea('');
                                        setPostOrPreOnloading({
                                            postOnloading: false,
                                            textData: ""
                                        });
                                        setPreShortcuts({
                                            ...preShortcuts,
                                            preOnloading: false
                                        });

                                        if (selectedText.length > 0) {
                                            setSelectedText(selectedText);
                                            setSelecting(true);
                                            setPostShortcutLoading(false);
                                            const logMsg = "Selected content - " + selectedText;
                                            const log_payload = createPayload(
                                                'Kustomer_AuthorAI_selected_content',
                                                'Success'
                                            );
                                            logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, log_message: logMsg });

                                            console.log('Double click - text selected:');
                                        }
                                        else {
                                            console.log("Into this one Double")
                                            // setSelecting();
                                        }
                                        break;

                                    default:
                                        console.log('Higher multi-click actions can be added as needed');
                                        break;
                                }
                            };

                            const handleMouseUp = () => {
                                const selection = window.getSelection();
                                const selectedText = selection.toString().trim();

                                if (selectedText.length > 0) {
                                    setSelectedText(selectedText);
                                    setSelecting(true);
                                    setPostOrPreOnloading({
                                        ...postOrPreOnloading
                                    });
                                    setPreShortcuts({
                                        ...preShortcuts,
                                        preOnloading: false
                                    });
                                    setPostShortcutLoading(false);
                                    const logMsg = "Selected content - " + selectedText;
                                    const log_payload = createPayload(
                                        'Kustomer_AuthorAI_selected_content',
                                        'Success'
                                    );
                                    logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, log_message: logMsg });

                                    console.log('Mouse selection - text selected:');
                                } else {
                                    // setSelecting(false);
                                    // setSelectedText('');
                                    // setPostShortcutLoading(true);
                                }
                            };

                            // Add event listener for click and mouseup events
                            document.addEventListener('click', xorClick, false);
                            document.addEventListener('mouseup', handleMouseUp, false);

                            // Cleanup event listeners on component unmount
                            return () => {
                                clearTimeout(pendingClick);
                                document.removeEventListener('click', xorClick);
                                document.removeEventListener('mouseup', handleMouseUp);
                            };


                        } else {
                            setSelectedText('')
                        }

                    }, [isLoggedStatus, isSettingStatus, selectedText, settingreg, ischeckboxType]);

                    useEffect(() => {
                        if ((selectedText == "") && (textArea == "")) {
                            // setSelecting(false);
                            setPostShortcutLoading(true);
                        }
                        if (((selectedText == "") && (textArea == "") && (selections?.length == 0) && !(preShortcuts?.preOnloading) && (preShortcuts?.preShortcutOption == ""))) {
                            setSelecting(false);
                            // setPostShortcutLoading(false);
                            // setPostShortcutLoading(true);
                        }

                        // if (textArea == "") {
                        //     setSelecting(false);
                        //     // setPostShortcutLoading(true);
                        //     // setPostOrPreOnloading({
                        //     //     ...postOrPreOnloading,
                        //     //     preOnloading: true
                        //     // });
                        // }
                    }, [selectedText, textArea, preShortcuts, selections]);

                    useEffect(() => { }, [selections]);

                    useEffect(() => {
                        if (scrollRef.current) {
                            scrollRef.current.scrollIntoView({ behavior: "smooth" });
                        }
                    }, [selections]);

                    useEffect(() => {
                        if (ischeckboxType == "promptogpt" || ischeckboxType == "knowledge_assist") {
                            setSelectedText('');
                            setSelecting(true);
                            setPostShortcutLoading(true);
                            setTextArea('');
                            // setPostpreConfig({});
                            setPreShortcuts({
                                ...preShortcuts,
                                preOnloading: false,
                                preShortcutOption: ""
                            });
                        }
                    }, [ischeckboxType])

                    useEffect(() => {
                    }, [isSelecting, selectedText, postpreConfig, postOrPreOnloading, isEmail, isAutoLoading, preShortcuts, promptoRes, toneWriting]);

                    
                    async function findLastResponse(result) {
                        try {
                            {
                                (result || []).map((item) => {
                                    if (item.attributes.direction === "in") {
                                        setLastUserRes(item.attributes.preview)
                                    }
                                    if (item.attributes.direction === 'out') {
                                        setLastUserRes('Agent')
                                    }
                                    if (item.attributes.channel === 'email') {
                                        setChannelType("email")
                                    }
                                })
                            };
                        } catch (error) {
                            console.log("Error in findLastResponse::", result)
                        }
                    }        

                    //Styles
                    const divStyle = {
                        display: 'flex',
                        alignItems: "center",
                        gap: "5px"
                    };

                    const promptoGpt_style = {
                        padding: "7px 5px",
                        margin: "10px 0px",
                        border: "1px solid",
                        background: "#D3D3D3",
                        textAlign: "Justify"
                    } 
                    
                    const common_style = { 
                        fontFamily: "poppins", 
                        fontSize: "16px", 
                        color: "#000000"
                    }

                    async function showPromptRes(isEmail, lastUserRes, model_type, usecase, authToken) {
                        try {
                            let autosuggestResponse = await autoSuggestApi(isEmail, lastUserRes, model_type, usecase, authToken, isAuthuu, settingreg);            
                            setPrompt_res({
                            top_responses: autosuggestResponse?.top_responses,
                            top_scores: autosuggestResponse?.top_scores
                            });
                        } catch (err) {
                            console.log("Error in showPromptRes::", err)
                        }
                    }

                    async function selectedCheckbox(value) {
                        try {
                            setCheckboxType(value)
                            if (value === 'promptogpt') {
                            const payload = createPayload(
                                'Kustomer_PromptoGPT_ON',
                                'Success'
                            );
                            const promptogpt_on_LogMsg = "PromptoGPT Turned ON";
                            if (settingreg) {
                                await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: payload, log_message: promptogpt_on_LogMsg });
                            }                        
                            
                            } else {
                            const payload = createPayload(
                                'Kustomer_KnowledgeAssist_ON',
                                'Success'
                            );
                            const knowledgeAssist_on_LogMsg = "KnowledgeAssist Turned ON";
                            if (settingreg) {
                                await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: payload, log_message: knowledgeAssist_on_LogMsg });
                            }
                            }
                        } catch (err) {
                            console.log("Error in selectedCheckbox::", err)
                        }
                    }

                    function promptoGPTResponse() {
                        let lst_ = ['hi', 'hello', 'how are you', 'whats up', 'hey', 'good morning', 'good evening', 'good night', 'how do you do', 'how are you?', 'whats up?', 'how do you do?', 'how are you ?', 'whats up ?', 'how do you do ?'];
                        
                        let data = [];
                        data = prompt_res?.top_scores.map((item, index) => {
                            if (item != 0) {
                            return prompt_res?.top_responses[index]
                            }
                        }).filter(response => response !== undefined);
                        try {
                            return (
                            <>
                                <div style={{
                                ...common_style,
                                margin: "10px 0px 5px",                                
                                fontWeight: "600",
                                color: "#000000",
                                fontFamily: "poppins",
                                fontSize: "16px"
                                }}>
                                Query
                                </div>
                                <div
                                style={{
                                    color: "#808080",
                                    fontWeight: "500",
                                    fontSize: "14px",
                                    fontFamily: "poppins"
                                }}
                                >
                                {lastUserRes}
                                </div>

                                {(isAutoLoading) ?
                                <div style={{
                                    ...common_style,
                                    margin: "10px 0px 5px",
                                    fontWeight: "600",
                                    color: "#000000",
                                    fontSize: "14px",
                                    display: "flex",
                                    gap: "8px",
                                    fontStyle: "normal",
                                    alignItems: "center",
                                    justifyContent: "flex-start"
                                }}>
                                    <span className={'loader-prompt'}></span>
                                    <span style={{
                                        color: '#000000'
                                        // color: 'transparent',
                                        // background: "linear-gradient(to left, rgb(220, 7, 213), rgb(6, 6, 192), rgb(161, 161, 5), rgb(153, 8, 220))",
                                        // WebkitBackgroundClip: "text",
                                    }}
                                    >Prompt<sup>AI</sup></span> is writing....
                                </div>
                                :
                                <div style={{
                                    ...common_style,
                                    margin: "10px 0px 5px",
                                    fontWeight: "600",
                                    color: "#000000"
                                }}>
                                    Responses
                                    {(lst_.includes(lastUserRes.toLowerCase())) ?
                                    <div className={'response-box'} style={{cursor: "not-allowed"}}>
                                        Small Talk Identified
                                    </div>
                                    :
                                    <>
                                        {(data?.length == 0) ?
                                        <div
                                            className={'response-box'}
                                            style={{cursor: "not-allowed"}}
                                        >
                                            {/*{item}*/}
                                            No match found for this data.
                                        </div>
                                        :
                                        <>
                                            {(data || []).map((item, index) => {
                                            const cleanedItem = item.replace(/john\s*->\s*/i, "");
                                            const payload = createPayload(
                                                'Kustomer_PromptoGPT_Received_Response',
                                                'Success'
                                            );
                                            let unique_uuid = generateUUID();
                                            let response_received_LogMsg = 'Response_'+(index+1)+ ": "+ cleanedItem;
                                            if (settingreg) {
                                                logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: payload, UUID: unique_uuid, log_message: response_received_LogMsg });
                                            }
                                            return (
                                                <div
                                                key={index}
                                                className={'response-box'}
                                                onClick={() => copyFunc(cleanedItem, index)}
                                                >
                                                {/*{item}*/}
                                                {cleanedItem}
                                                {(copied === index) && <span className={'copied-message'}>Copied</span>}
                                                </div>

                                            )
                                            })}
                                        </>
                                        }
                                    </>
                                    }
                                </div>
                                }
                            </>
                            )
                        } catch (error) {
                            console.log("Error in promptoGPTResponse:: ", error)
                        }
                    }

                    async function loginBtnAPI() {
                        setLoading(true);
                        let endpoint = '/v1/commands/' + isAuthuu.appId + '.app.login_api_data/run';
                        try {
                            let resdata = await KustomerRequest({
                            url: endpoint,
                            method: 'POST',
                            body: {
                                "headers": {
                                    "CF-ACCESS-CLIENT-ID":"57cf23a5470bb331979b5353e2205b25.access",
                                    "CF-ACCESS-CLIENT-SECRET":"ca8fe3e2ae9569d1944b09e583a7dd5a181359dc3f18d2f1c3814225f1f76813"
                                },
                                "body": {
                                    "email": isEmail
                                }
                            }
                            },
                            (err, response) => {
                                if (err) {
                                console.log("Into 1")
                                return 'Failed to process return'
                                } else if (response.responseBody.errors) {
                                console.log("Into 2")
                                return response.responseBody.errors.message;
                                }
                            }
                            );
                            let loginResponse = resdata?.data?.attributes?.responseBody;
                            if (loginResponse?.status === true) {
                            sessionStorage.setItem('authorAILoggedIn', true);
                            setLoggedStatus(true);
                            setApiCall(false)
                            // settingResponse();
                            settingBtnAPI()
                            }
                        } catch (err) {
                            console.log("Error in loginBtnAPI::", err)
                        }
                    }

                    const fetchupdatedGlobalConfigApi = async (user_setting_response, apitoken, apikey, authorAIInstance_data) => {
                        try {
                            let endpoint = isAuthuu?.dev_normal_url + "/api/external/getUsecaseConfig/"+authorAIInstance_data[0]?.id;
                            let fetchUpdatedRes = await fetch(endpoint, {
                                method: "GET",
                                // headers: dev_headers
                                "headers": {
                                    // "Content-Type": "application/json",
                                    "x-apitoken": apitoken,
                                    "x-apikey": apikey,
                                    "CF-Access-Client-Id": user_setting_response?.settings.CF_Access_Client_Id,
                                    "CF-Access-Client-Secret": user_setting_response?.settings.CF_Access_Client_Secret
                                },
                            });

                            if (!(fetchUpdatedRes.ok)) {
                                throw new Error("HTTP error! status:", fetchUpdatedRes?.status)
                            }
                            const data = await fetchUpdatedRes.json();
                            let custom_prompt = {
                                displayName: "Write a Custom Prompt",
                                name: "custom_prompt",
                                useCase: {
                                    aiName: "custom_prompt"
                                }
                            };
                            let configRes = data;
                            let preshortCutArray = configRes?.data?.preShortcuts?.filter(item => item.name !== "TEMPLATE_MENU");
                            configRes?.data?.preShortcuts?.push(custom_prompt);
                            preshortCutArray?.push(custom_prompt);
                            setPostpreConfig({
                                postShortcuts: configRes?.data?.postShortcuts,
                                // preShortcuts: configRes?.data?.preShortcuts
                                preShortcuts: preshortCutArray
                            });
                        } catch (err) {
                            console.log("Error in fetchupdatedGlobalConfigApi::", err);
                        }
                    }

                    const updatedGlobalConfigApi = async () => {
                        try {
                            let endpoint = '/v1/commands/'+isAuthuu.appId+'.app.updated_global_config_api/run';
                            let updatedResponse = await KustomerRequest({
                                url: endpoint,
                                method: "POST",
                                body: {
                                    "headers": {
                                        "x-apikey": "{{{dev_apiKey}}}",
                                        "x-apitoken": "{{{dev_apitoken}}}",
                                        "CF-ACCESS-CLIENT-ID": "{{{cloudFlare_Id}}}",
                                        "CF-ACCESS-CLIENT-SECRET": "{{{cloudFlare_Secret}}}"
                                    }
                                }
                            },  (err, res) => {
                                    if (err) {
                                        return 'Failed to process return'
                                    }
                                }
                            );
                        } catch (error) {
                            console.log("Error in updatedGlobalConfigApi::", error)
                        }
                    }

                    const globalConfigApi = async (x_apitoken, x_apikey) => {
                        try {
                            let endpoint = '/v1/commands/'+isAuthuu.appId+'.app.global_config_api/run';
                            let response = await KustomerRequest({
                                url: endpoint,
                                method: 'POST',                            
                                body: {                                    
                                    headers: {
                                        "x-apitoken": x_apitoken,
                                        "x-apikey": x_apikey                                    
                                    }                         
                                }
                            },(err, response) => {                                    
                                if (err) {
                                    return 'Failed to process return'
                                } 
                            }
                            );
                            let custom_prompt = {
                                displayName: "Write a Custom Prompt",
                                name: "custom_prompt",
                                useCase: {
                                    aiName: "custom_prompt"
                                }
                            };
                            let configRes = response?.data?.attributes?.responseBody;
                            configRes?.data?.preShortcuts?.push(custom_prompt);
                            setPostpreConfig({
                                postShortcuts: configRes?.data?.postShortcuts,
                                preShortcuts: configRes?.data?.preShortcuts
                            });
                        } catch (err) {
                            console.log("Error in globalConfigApi::", err);
                        }                
                    }

                    async function settingBtnAPI() {
                        setLoading(true)
                        let endpoint = '/v1/commands/'+isAuthuu.appId+'.app.setting_api_data/run';
                        try {
                            let data = await KustomerRequest({
                                url: endpoint,
                                method: 'POST',
                                body: {
                                    "headers": {
                                        "X-ApiToken": "{{{aauthtoken}}}",
                                        "X-ApiKey": "{{{aapikey}}}",
                                        "Accept": "application/json",
                                        "Content-Type": "application/json",
                                        "CF-ACCESS-CLIENT-ID":"57cf23a5470bb331979b5353e2205b25.access",
                                        "CF-ACCESS-CLIENT-SECRET":"ca8fe3e2ae9569d1944b09e583a7dd5a181359dc3f18d2f1c3814225f1f76813"
                                    },
                                    "body": {
                                        "email": isEmail
                                    }
                                }
                            },
                                (err, response) => {
                                    if (err) {
                                        console.log("Into 1")
                                        setLoading(false);
                                        return 'Failed to process return'
                                    } else if (response.responseBody.errors) {
                                        console.log("Into 2")
                                        return response.responseBody.errors.message;
                                    }
                                }
                            );
                            let settingRes = data?.data?.attributes?.responseBody
                            if (settingRes?.message === "Authentication failed ") {
                                sessionStorage.setItem('authorAIStatus', false);
                                setSettingStatus(false);
                                setLoading(false);
                            } else {
                                sessionStorage.setItem('authorAIStatus', true);
                                // setSettingStatus(true);
                                setSettingreg({
                                    refreshToken: settingRes?.refresh_token,
                                    settingResponse: settingRes,
                                    setting_token: settingRes?.authToken,
                                    CF_Access_Client_Id: settingRes?.settings?.CF_Access_Client_Id,
                                    CF_Access_Client_Secret: settingRes?.settings?.CF_Access_Client_Secret
                                });
                                // setSettingreg(settingRes);
                                // setLoading(false);
                                const logMsg = "Successfully LoggedIn";
                                const payload = createPayload(
                                'Kustomer_LoggedIn',
                                'Success'
                                );
                                await logsAPI({ isAuthuu: isAuthuu, setting_token: settingRes?.authToken, user_setting: settingRes, PAYLOAD_FOR_EVENT: payload, log_message: logMsg });
                                // const { authToken, clientAuthToken, model_type, usecase, promptoGPT_toggle, knowledgeAssist_toggle } = await generate_auth_client_token(settingRes, isEmail);
                                // globalConfigApi(settingRes?.settings.x_apitoken, settingRes?.settings.x_apikey);
                                const { authToken, clientAuthToken, model_type, usecase, promptoGPT_toggle, knowledgeAssist_toggle, authorAI_toggle, authorAIInstance } = await generateTokenApi(settingRes, isEmail, isAuthuu);
                                fetchupdatedGlobalConfigApi(settingRes, settingRes?.settings.x_apitoken, settingRes?.settings.x_apikey, authorAIInstance);
                                setGenerateToken(
                                {
                                    authToken: authToken,
                                    client_authtoken: clientAuthToken,
                                    promptoGPT_toggle: promptoGPT_toggle,
                                    knowledgeAssist_toggle: knowledgeAssist_toggle,
                                    authorAI_toggle: authorAI_toggle,
                                    model_type: model_type,
                                    usecase: usecase
                                }
                                )
                            }
                        } catch (err) {
                            console.log("Error in settingBtnAPI::", err)
                        }
                    }

                    async function logoutBtn() {
                        try {
                            setLoading(false);
                            sessionStorage.setItem('authorAILoggedIn', false);
                            setLoggedStatus(false);
                            setApiCall(false);
                            sessionStorage.setItem('authorAIStatus', false);
                            setSettingStatus(false);
                            setCheckboxType('');
                            setAutoLoading(false);
                        } catch (err) {
                            console.log("Error in logoutBtn::", err)
                        }
                    }

                    const regenerate_authToken = async () => {
                        try {
                            const { authToken, clientAuthToken, model_type, usecase } = await generateTokenApi(settingreg?.settingResponse, isEmail, isAuthuu);
                            setGenerateToken(
                                {
                                    authToken: authToken,
                                    client_authtoken: clientAuthToken,
                                    model_type: model_type,
                                    usecase: usecase
                                }
                            );
                            return { authToken, model_type };
                        } catch (error) {
                            console.log("Error in regenerate_authToken::", error);
                        }
                    }

                    const initialPage = () => {
                        return (
                            <>
                                <div className={'write_paste_selected_txt'}>
                                    Write/Select Text to Start
                                </div>
                            </>
                        )
                    }

                    const post_sub_category_items = async (e, item, sub_category, index) => {
                        try {
                            e.stopPropagation();
                            setPostShortcutLoading(true);
                            let textData;
                            if (postOrPreOnloading?.postOnloading) {
                                textData = postOrPreOnloading?.textData;
                            } else {
                                textData = textArea ? textArea : selectedText;
                            }

                            let auto_authToken;
                            let model_type;
                            if (generateToken?.authToken || generateToken?.model_type) {
                                auto_authToken = generateToken?.authToken;
                                model_type = generateToken?.model_type;
                            } else {
                                let data = await regenerate_authToken();
                                auto_authToken = data?.authToken;
                                model_type = data?.model_type
                            }

                            let payload = {
                                body: {
                                    "application_name": "TaskScribe",
                                    "model_type": model_type,
                                    // "usecase": sub_category?.useCase?.aiName,
                                    "usecase": sub_category?.prompt,
                                    "question": textData,
                                    "user_id": isEmail,
                                    //"enable_automasking": true
                                },
                                headers: {
                                    "Content-Type": "application/json",
                                    "X-Authtoken": auto_authToken,
                                    "CF-ACCESS-CLIENT-ID": settingreg?.CF_Access_Client_Id,
                                    "CF-ACCESS-CLIENT-SECRET": settingreg?.CF_Access_Client_Secret
                                },
                                category: {
                                    main_category: item?.displayName,
                                    sub_category: sub_category?.displayName
                                }
                            }
                            if (sub_category?.useCaseOption) {
                                payload.body['usecase_options'] = sub_category?.useCaseOption?.aiName
                            }
                            let unique_uuid = generateUUID();
                            const log_payload = createPayload(
                                'Kustomer_AuthorAI_Post_Category_Clicked',
                                'Success'
                            );
                            let post_categoty_msg = "Clicked the prompt option - " + " " + sub_category?.displayName;
                            await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, UUID: unique_uuid, log_message: post_categoty_msg });

                            postPreAutoSuggestApi(payload, isAuthuu)
                        } catch (err) {
                            console.log("Error in post_sub_category_items::", err);
                        }
                    }

                    const ps_main_category = async (item) => {
                        try {
                            let textData;
                            if (postOrPreOnloading?.postOnloading) {
                                textData = postOrPreOnloading?.textData;
                            } else {
                                textData = textArea ? textArea : selectedText;
                            }

                            setPostShortcutLoading(true);

                            let auto_authToken;
                            let model_type;
                            if (generateToken?.authToken || generateToken?.model_type) {
                                auto_authToken = generateToken?.authToken;
                                model_type = generateToken?.model_type;
                            } else {
                                let data = await regenerate_authToken();
                                auto_authToken = data?.authToken;
                                model_type = data?.model_type
                            }

                            let payload = {
                                body: {
                                    "application_name": "TaskScribe",
                                    "model_type": model_type,
                                    // "usecase": item?.useCase?.aiName,
                                    usecase: item?.prompt,
                                    "question": textData,
                                    "user_id": isEmail,
                                    // "enable_automasking": true
                                },
                                headers: {
                                    "Content-Type": "application/json",
                                    "X-Authtoken": auto_authToken,
                                    "CF-ACCESS-CLIENT-ID": "${client_id}",
                                    "CF-ACCESS-CLIENT-SECRET": "${client_sec}"
                                },
                                category: {
                                    main_category: item?.displayName,
                                    sub_category: ""
                                }

                            }
                            if (item?.useCaseOption) {
                                payload.body['usecase_options'] = item?.useCaseOption?.aiName
                            }
                            let unique_uuid = generateUUID();
                            const log_payload = createPayload(
                                'Kustomer_AuthorAI_Post_Category_Clicked',
                                'Success'
                            );
                            let post_categoty_msg = "Clicked the prompt option - " + " " + item?.displayName;
                            await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, UUID: unique_uuid, log_message: post_categoty_msg });

                            postPreAutoSuggestApi(payload, isAuthuu)
                        } catch (err) {
                            console.log("Error in ps_main_category::", err);
                        }
                    }

                    const post_shortcut_content = () => {
                        return (
                            <div className="post_shortcut_list">
                                {(postpreConfig?.postShortcuts || []).map((item) => {
                                    return (
                                        <div
                                            className={'ps_single_item'}
                                            onClick={() => (item?.subUseCases.length == 0) && ps_main_category(item)}
                                        >
                                            <div
                                                className={'ps_main_list_names'}
                                            // onMouseDown={() => setPostShortcutLoading(true)}

                                            >
                                                {item.displayName}
                                            </div>
                                            <div className={'post_shortcut_subcategory'}>
                                                {(item.subUseCases || []).map((sub, index) => {
                                                    return (
                                                        <div
                                                            className={sub?.name ? 'ps_subcategory_item' : ''}
                                                            // onMouseDown={(e) => post_sub_category_items(e, sub)}
                                                            onClick={(e) => post_sub_category_items(e, item, sub, index)}
                                                        >
                                                            {sub?.displayName}
                                                        </div>
                                                    )
                                                })}
                                            </div>
                                        </div>
                                    )
                                })}
                            </div>
                        )
                    }

                    const handleReplyTextArea = (e) => {
                        try {
                            if (preShortcuts?.preShortcutOption) {
                                console.log("Into this ")
                                setPostShortcutLoading(true);   // not to show
                            } else {
                                console.log("Into 2 ")
                                setPostShortcutLoading(false);
                                setPostOrPreOnloading({
                                    postOnloading: false,
                                    textData: ""
                                });
                                setPreShortcuts({
                                    ...preShortcuts,
                                    preOnloading: false
                                })
                            }
                            setTextArea(e.target.value);
                            setSelecting(true);
                            setSelectedText('');
                        } catch (err) {
                            console.log("Err in handleReplyTextArea:: ", err)
                        }
                    }

                    const enteredTextAreas = async () => {
                        try {
                            let auto_authToken;
                            let model_type;
                            if (generateToken?.authToken || generateToken?.model_type) {
                                auto_authToken = generateToken?.authToken;
                                model_type = generateToken?.model_type;
                            } else {
                                let data = await regenerate_authToken();
                                auto_authToken = data?.authToken;
                                model_type = data?.model_type
                            }
                            let payload = {
                                body: {
                                    "application_name": "TaskScribe",
                                    "model_type": model_type,
                                    "usecase": preShortcuts?.preShortcutOption?.prompt,
                                    "question": textArea,
                                    "user_id": isEmail,
                                    // "enable_automasking": true
                                },
                                headers: {
                                    "Content-Type": "application/json",
                                    "X-Authtoken": auto_authToken,
                                    "CF-ACCESS-CLIENT-ID": settingreg?.CF_Access_Client_Id,
                                    "CF-ACCESS-CLIENT-SECRET": settingreg?.CF_Access_Client_Secret
                                },
                                category: {
                                    main_category: preShortcuts?.preShortcutOption?.displayName,
                                    sub_category: ""
                                }

                            }
                            if (preShortcuts?.preShortcutOption?.name != "TEMPLATE_MENU") {
                                // payload.body['usecase_options'] = preShortcuts?.preShortcutOption?.name
                            } else {
                                payload.body['usecase_options'] = {
                                    name: "email",
                                    voice_tone: toneWriting?.selected_tone,
                                    writing_style: toneWriting?.selected_writing_style
                                }
                            }
                            postPreAutoSuggestApi(payload, isAuthuu)
                        } catch (err) {
                            console.log("Error in enteredTextAreas::", err);
                        }
                    }

                    const pre_post_textarea = () => {
                        return (
                            <>
                                {(preShortcuts?.preShortcutOption) &&
                                    <div className={'selected_pre_option'}>
                                        <div>{preShortcuts?.preShortcutOption && preShortcuts?.preShortcutOption?.displayName}</div>
                                        <div
                                            onClick={() => {
                                                setPreShortcuts({
                                                    ...preShortcuts,
                                                    preOnloading: false,
                                                    preShortcutOption: ""
                                                });
                                                setTextArea('')
                                            }}
                                            style={{ cursor: "pointer" }}
                                        >
                                            x
                                        </div>
                                    </div>
                                }

                                {preShortcuts?.preShortcutOption?.name == "TEMPLATE_MENU" &&
                                    <div className="promptoWritingStyleOptions">
                                        <div className="tone_style_content">
                                            <div>Tone</div>
                                            <select 
                                                value={toneWriting.selected_tone}
                                                className="tone_lists"
                                                onChange={(e) => setToneWriting({
                                                    ...toneWriting,
                                                    selected_tone: e.target.value
                                                })}
                                            >
                                                {((promptoRes?.promptToneOptions) || []).map((item) => {
                                                    return (
                                                        <option className='tone_item' value={item}>{item}</option>
                                                    )
                                                })}
                                            </select>

                                        </div>
                                        <div className="tone_style_content">
                                            <div>Tone</div>
                                            <select
                                                value={toneWriting.selected_writing_style}
                                                className="tone_lists"
                                                onChange={(e) => setToneWriting({
                                                    ...toneWriting,
                                                    selected_writing_style: e.target.value
                                                })}
                                            >
                                                {((promptoRes?.promptoWritingStyleOptions) || []).map((item) => {
                                                    return (
                                                        <option className='tone_item' value={item}>{item}</option>
                                                    )
                                                })}
                                            </select>

                                        </div>
                                    </div>
                                }

                                <div className={"pre_ta_parent"}>
                                    <div className={'pre_textarea'}>
                                        <textarea
                                            value={textArea}
                                            // readOnly={!(userLang?.trim())}
                                            className={'textarea_input'}
                                            placeholder={'Write/Select any text...'}
                                            onChange={handleReplyTextArea}
                                            onFocus={() => setPreShortcuts({
                                                ...preShortcuts,
                                                preOnloading: false
                                            })}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') {
                                                    e.preventDefault();  // Prevents new line in the textarea
                                                    enteredTextAreas();  // Call the function
                                                }
                                            }}
                                        />
                                        {preShortcuts?.preShortcutOption == "" &&
                                            <div
                                                className={'magic_icon'}
                                                onClick={() => {
                                                    setPreShortcuts({
                                                        ...preShortcuts,  // Spread the current state
                                                        // preOnloading: true     // Update the specific field    
                                                        preOnloading: !(preShortcuts?.preOnloading)
                                                    });
                                                    setPostShortcutLoading(true); // Make it off by giving opposite
                                                    setSelectedText('');
                                                    setSelecting(true)
                                                }}
                                            >
                                                ${pre_magic_icon}
                                            </div>}
                                    </div>
                                </div>
                            </>

                        )
                    }

                    const selectedPreShortcut = async (pre_object) => {
                        try {
                            setSelecting(true);
                            setPostShortcutLoading(true);
                            if (pre_object?.displayName == "Templates") {
                                setPreShortcuts({
                                    ...preShortcuts,
                                    preOnloading: false,
                                    preShortcutOption: { displayName: promptoRes?.shownforTemplate, name: pre_object?.name, usecase: { aiName: pre_object?.useCase?.aiName } }
                                });
                            } else {
                                setPreShortcuts({
                                    ...preShortcuts,
                                    preOnloading: false,
                                    preShortcutOption: pre_object
                                });
                            }
                            

                            let unique_uuid = generateUUID();
                            const log_payload = createPayload(
                                'Kustomer_AuthorAI_PreShortcut_Option_Clicked',
                                'Success'
                            );
                            let pre_categoty_msg = "Clicked the prompt option - " + " " + pre_object?.displayName;
                            await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, UUID: unique_uuid, log_message: pre_categoty_msg });

                        } catch (err) {
                            console.log("Error in selectedPreShortcut:: ", err);
                        }
                    }

                    const pre_shortcut_content = () => {
                        return (
                            <div className={'pre_shortcut_list'}>
                                {(postpreConfig?.preShortcuts || []).map((preshortcut) => {
                                    return (
                                        <div className={'pr_single_item'} onClick={() => selectedPreShortcut(preshortcut)}>
                                            {(preshortcut?.name == "TEMPLATE_MENU") ?
                                                <div style={{margin: "2px 0px 0px"}}>
                                                    ${templates_icon}
                                                </div>
                                                :
                                                ((preshortcut?.name == "custom_prompt") ?
                                                    <div style={{margin: "2px 0px 0px"}}>${custom_prompt_icon}</div>
                                                    :
                                                    <></>
                                                )
                                            }
                                            <div>{preshortcut?.displayName}</div>
                                        </div>
                                    )
                                })
                                }
                            </div>
                        )
                    }

                    const post_pre_select_box = () => {
                        return (
                            <>
                                {!(postShortcutLoading) && <div className={'postShortcutLoadingv'}>{post_shortcut_content()}</div>}
                                {(preShortcuts?.preOnloading) && <div className={'preShortcutLoadingv'}>{pre_shortcut_content()}</div>}
                            </>
                        )
                    }

                    const selected_txt_post_blog = (selection, index) => {
                        return (
                            <>
                                <div className={'selected_txt_post_blog'}>
                                    <div className={'st_response'}>
                                        <div className={'select_text_heading'}>Selected Text</div>
                                        {/* <div className={'query'}>{selectedText}</div> */}
                                        <div className={'query'}>{selection?.showText}</div> 
                                    </div>                            
                                </div>
                                <div className={'overall_icon_pack'}>
                                    <div className="action_items">{selection?.category?.main_category}{selection?.category?.sub_category && ("/"+""+selection?.category?.sub_category)}</div>

                                    {/* Render formatted content without dangerouslySetInnerHTML */}
                                    {/*<div className="ac_content">
                                        {(postpreConfig?.postpreResponse || "")} formattedResponseData
                                    </div>*/}
                                    {(selection?.category?.sub_category) && (selection?.category?.sub_category == "Table") ?
                                        <div 
                                        className="ac_content"
                                        dangerouslySetInnerHTML={{ __html: selection?.formattedResponseData }}
                                        >
                                            {/*{(selection?.formattedResponseData || "")}*/}
                                        </div> 
                                        :
                                        <div className="ac_content">
                                            {(selection?.formattedResponseData || "")}
                                        </div>
                                    }

                                    {iconItems(selection, index)}
                                </div>
                            </>                            
                        )
                    }

                    async function copyFunc(text, index, ) {
                        try {
                            navigator.clipboard.writeText(text)
                            .then(() => {
                                setCopied(index);
                                setTimeout(() => {
                                    setCopied(null)
                                }, 1000); //Hide the "Copied" message after 2secs
                            })
                            .catch((err) => {
                                console.log("Failed to copy::", err)
                            });
                        } catch (err) {
                            console.log("Error in copy::", err)
                        }
                    }

                    const reloadFunc = async (selectionData, index) => {
                        try {
                            setPostShortcutLoading(true);

                            let payload = {
                                body: {
                                    "application_name": "TaskScribe",
                                    "model_type": generateToken?.model_type,
                                    "usecase": selectionData?.res_useCase_option?.usecase,
                                    "question": selectionData?.showText,
                                    "user_id": isEmail,
                                    // "enable_automasking": true
                                },
                                headers: {
                                    "Content-Type": "application/json",
                                    "X-Authtoken": generateToken?.authToken,
                                    "CF-ACCESS-CLIENT-ID": settingreg?.CF_Access_Client_Id,
                                    "CF-ACCESS-CLIENT-SECRET": settingreg?.CF_Access_Client_Secret
                                },
                                category: {
                                    main_category: selectionData?.category?.main_category,
                                    sub_category: (selectionData?.category?.sub_category)?selectionData?.category?.sub_category:""
                                }
                            }

                            if (selectionData?.res_useCase_option?.useCaseOption) {
                                payload.body['usecase_options'] = selectionData?.res_useCase_option?.useCaseOption
                            }
                            let unique_uuid = generateUUID();
                            const log_payload = createPayload(
                                'Kustomer_AuthorAI_Reload_Option_Clicked',
                                'Success'
                            );
                            let post_categoty_msg = "Reload Query - " + " " + selectionData?.showText;
                            await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: log_payload, UUID: unique_uuid, log_message: post_categoty_msg });
                            postPreAutoSuggestApi(payload, isAuthuu)

                        } catch (err) {
                            console.log("Error in reloadFunc::", err)
                        }
                    }

                    const iconItems = (selectionData, index) => {
                        return (
                            <div className="iconItems">
                                <div 
                                    onClick={() => reloadFunc(selectionData, index)}
                                >${rotate_icon}</div>
                                <div className={'copy_data'} onClick={() => copyFunc(selectionData?.originalData, index)}>
                                    {(copied === index) && <span className={'copied-message-ai'}>Copied!</span>}
                                    ${copy_icon}
                                </div>
                                <div onClick={() => handleLikeClick(index, selectionData)}>
                                    {(likedState[index]) ? ${liked_thumbs_up} : ${thumbs_up_icon}}                                    
                                </div>
                                <div onClick = {() => handleDislikeClick(index, selectionData)}>
                                    {(dislikedState[index]) ? ${disliked_thumbs_down} : ${thumbs_down_icon}}
                                </div>
                                <div
                                    onClick={() => {setPostOrPreOnloading({
                                            ...postOrPreOnloading,  // Spread the current state
                                            postOnloading: true,     // Update the specific field
                                            textData: selectionData?.showText
                                        }); 
                                        setPostShortcutLoading(!(postShortcutLoading))
                                        // setPostShortcutLoading(false)}
                                    }}
                                >
                                    ${magic_icon}
                                </div>
                            </div>
                        )
                    }

                    const authorAIDashboardComponents = () => {
                        return (
                            <>
                                {!(isSelecting) && initialPage()}                                
                                <div style={{ maxHeight: '310px', overflowY: 'auto' }}>
                                    {/*{!(isSelecting) && initialPage()}*/}   
                                    {/*{(selectedText != "") && selected_txt_post_blog()}*/}
                                    {/* Render list of selected texts and responses */}
                                    
                                    <>
                                        {isAutoLoading ?
                                            <>
                                                {
                                                    (selections.length > 0 && selections.map((selection, index) => (
                                                        <div key={index} ref={index === selections.length - 1 ? scrollRef : null}>
                                                            {selected_txt_post_blog(selection, index)}
                                                            {/* Place scrollRef after the last response */}
                                                            {/*index === selections.length - 1 && <div ref={scrollRef}></div>*/}
                                                        </div>
                                                    )))
                                                }
                                                <>
                                                    <div id="spinner_bounce" style={{ display: "block" }}>
                                                        <div className="spinner_bounce" style={{ padding: "0px 15px" }}>
                                                            <div className="bounce1"></div>
                                                            <div className="bounce2"></div>
                                                            <div className="bounce3"></div>
                                                        </div>
                                                    </div>
                                                </>
                                            </>
                                            : <>
                                                {selections.length > 0 && selections.map((selection, index) => (
                                                    <div key={index} ref={index === selections.length - 1 ? scrollRef : null}>
                                                        {selected_txt_post_blog(selection, index)}
                                                        {/* Place scrollRef after the last response */}
                                                        {/*index === selections.length - 1 && <div ref={scrollRef}></div>*/}
                                                    </div>
                                                ))}
                                            </>
                                        }
                                    </>                              
                                </div> 
                                {(selectedText) &&
                                    <div className={'selected_txt_post_blog'}>
                                        <div className={'st_response'}>
                                            <div className={'select_text_heading'}>Selected Text</div>
                                            {/* <div className={'query'}>{selectedText}</div> */}

                                            <div className={'query'}>{selectedText}</div>

                                        </div>
                                    </div>
                                }
                                {((selectedText != "") || (textArea !== "") || (textArea == "") || (postOrPreOnloading?.textData)) && post_pre_select_box()}
                            </>
                            
                        )
                    }

                    const selectingAI = async (type) => {
                        try {
                            setCheckboxType(type)
                            if (type === 'promptogpt') {
                                const payload = createPayload(
                                    'Kustomer_PromptoGPT_ON',
                                    'Success'
                                );
                                const promptogpt_on_LogMsg = "PromptoGPT Turned ON";
                                if (settingreg) {
                                    await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: payload, log_message: promptogpt_on_LogMsg });
                                }

                            } else if (type == "knowledge_assist") {
                                const payload = createPayload(
                                    'Kustomer_KnowledgeAssist_ON',
                                    'Success'
                                );
                                const knowledgeAssist_on_LogMsg = "KnowledgeAssist Turned ON";
                                if (settingreg) {
                                    await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: payload, log_message: knowledgeAssist_on_LogMsg });
                                }
                            } else {
                                const payload = createPayload(
                                    'Kustomer_AuthorAI_ON',
                                    'Success'
                                );
                                const knowledgeAssist_on_LogMsg = "Kustomer_AuthorAI Turned ON";
                                if (settingreg) {
                                    await logsAPI({ isAuthuu: isAuthuu, setting_token: settingreg?.setting_token, user_setting: settingreg?.settingResponse, PAYLOAD_FOR_EVENT: payload, log_message: knowledgeAssist_on_LogMsg });
                                }
                            }
                        } catch (err) {
                            console.log("Error in selectingAI::", err)
                        }
                    }

                    const middlePart = () => {
                        return (
                            <>
                                {(isSettingStatus) && (generateToken?.promptoGPT_toggle || generateToken?.knowledgeAssist_toggle || generateToken?.authorAI_toggle) ?
                                    <div className="latest_AI_types">
                                        {(generateToken?.promptoGPT_toggle === "true") &&
                                            (((lastUserRes === 'Agent') || (channelType === "email")) ?
                                                <div
                                                    className={"new_non_selected_prompts_notAllowed notAllowed"}
                                                // onClick={() => ((lastUserRes === 'Agent') || (channelType === "email")) ? console.log() : selectingAI("promptogpt")}
                                                >
                                                    Prompt<sup>AI</sup>
                                                </div> :
                                                <div
                                                    className={ischeckboxType == "promptogpt" ? "new_selected_prompts" : "new_non_selected_prompts"}
                                                    onClick={() => selectingAI("promptogpt")}
                                                >
                                                    Prompt<sup>AI</sup>
                                                </div>
                                            )
                                        }
                                        {(generateToken?.knowledgeAssist_toggle === "true") &&
                                            <div
                                                className={ischeckboxType == "knowledge_assist" ? "new_selected_prompts" : "new_non_selected_prompts"}
                                                onClick={() => selectingAI("knowledge_assist")}
                                            >
                                                Assist<sup>AI</sup>
                                            </div>}
                                        {(generateToken?.authorAI_toggle === "true") &&
                                            <div
                                                className={ischeckboxType == "authorAI" ? "new_selected_prompts" : "new_non_selected_prompts"}
                                                onClick={() => selectingAI("authorAI")}
                                            >
                                                Author<sup>AI</sup>
                                            </div>}
                                    </div>
                                    :
                                    <div style={{
                                        display: "flex",
                                        margin: "10px 0px 5px",
                                        fontWeight: "600",
                                        color: "#000000",
                                        fontSize: "14px",
                                        gap: "8px",
                                        fontStyle: "normal",
                                        alignItems: "center",
                                        fontFamily: "poppins"
                                    }}>
                                        <span className={'loader-prompt'}></span>
                                        <span>TaskGPT is loading...</span>
                                    </div>


                                }

                            </>

                        )
                    }

                    const dashboardComponent = () => {
                        // let url=isAuthuu?.url_def;
                        let url=isAuthuu?.url_def+"/chatbot/floatingwidget?authToken=";
                        let token = generateToken?.client_authtoken;
                        let end_url='&email='+isEmail+'&clientType=extension';
                        let last_url=url+token+end_url;
                        return (
                            //<div style={{ padding: '15px' }}>
                            <div style={{ padding: '0px' }}>
                                {/*<img src='/images/logo.svg' /> TaskGPT*/}
                                <div style={{
                                    display: "flex", 
                                    justifyContent: "space-between",
                                    alignItems: "center"
                                    }}
                                >
                                    <div
                                    style={{ 
                                        ...common_style,
                                        margin: "10px 0px",
                                        fontWeight: "500"
                                    }}
                                    >
                                    Welcome, <span style={{ fontWeight: "600" }}>{name}</span>
                                    </div>
                                    <div style={{
                                    textDecoration: "underline",
                                    fontSize: "15px",
                                    fontFamily: "Poppins",
                                    color: "#005EFF",
                                    cursor: "pointer",
                                    }}
                                    onClick={() => logoutBtn()}
                                    >
                                    Logout
                                    </div>
                                </div>
                            
                                {/*checkboxContent()*/}
                                {middlePart()}
                                <>
                                    {(ischeckboxType == 'promptogpt') ?
                                    <>
                                        {(lastUserRes !== "Agent") ?  promptoGPTResponse()  : <></>}
                                    </>
                                    :
                                    ((ischeckboxType == 'knowledge_assist') ?
                                        // (generateToken?.client_authtoken) &&
                                        <div style={{ margin: "10px 0px 0px" }}>
                                        
                                        <iframe
                                            id="taskgpt"
                                            src={last_url}
                                            // allow = "clipboard-read; clipboard-write"
                                            style={{
                                            height: '453px',
                                            width: "100%"
                                            }}                  
                                        >

                                        </iframe>

                                        </div>
                                        :
                                        ((ischeckboxType === "authorAI") ? 
                                            <></>
                                        :<></>
                                        )
                                    )
                                    }
                                </>
                            </div >
                        )
                    }      

                    const loginComponent = () => {
                        return (
                            <div style={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', margin: "12px 0px 0px"}}>
                                <div>
                                    <div 
                                    style={{
                                        margin: "0px 0px 10px",
                                        fontFamily: "poppins",
                                        fontSize: "16px",
                                        fontWeight: "600",
                                        color: "#282829"
                                    }}
                                    >
                                    Email
                                    </div>
                                    <input
                                    style={
                                        {
                                        padding: '10px',
                                        border: '1px solid #B3B3B3',
                                        background: '#FFFFFF',
                                        borderRadius: '8px',
                                        color: '#808080',
                                        fontFamily: 'Poppins',
                                        fontSize: '16px',
                                        width: '100%',
                                        outline: 'none'
                                        }
                                    }
                                    id="email_id"
                                    value={isEmail}
                                    readOnly
                                    />
                                </div>
                                {!(isLoading) ?
                                    <button
                                    style={{
                                        padding: "12px 48px",
                                        borderRadius: "40px",
                                        background: " #005EFF",
                                        color: "#FFFFFF",
                                        border: "1px solid #005EFF",
                                        margin: "21px 0px 11px",
                                        fontFamily: 'Poppins',
                                        fontSize: '16px',
                                        cursor: 'pointer'
                                    }}
                                    onClick={() => loginBtnAPI()}
                                    >
                                    Login
                                    </button>
                                    :
                                    <button
                                    style={{
                                        display: "flex",
                                        justifyContent: "center",
                                        gap: "8px",
                                        alignItems: "center",
                                        padding: "12px 48px",
                                        borderRadius: "40px",
                                        background: " #005EFF",
                                        color: "#FFFFFF",
                                        border: "1px solid #005EFF",
                                        margin: "21px 0px 11px",
                                        fontFamily: 'Poppins',
                                        fontSize: '16px',
                                        cursor: 'not-allowed'
                                    }}
                                    disabled
                                    >
                                    <span className={'loader'}></span>  Loading...
                                    </button>

                                }
                            </div >
                        )
                    }

                    const footerPart = () => {
                        const currentYear = new Date().getFullYear();
                        return (
                            <div style={{
                            fontSize: "14px",
                            fontWeight: "500",
                            fontFamily: "poppins",
                            margin: "10px 0px",
                            textAlign: "center",
                            color: "#000000"
                            }}
                            >
                            <p>Version: 1.0.0 | TaskUs @ {currentYear} | <a style={{color: "#005EFF", textDecoration: "underline"}} href="https://www.taskus.com/security/" target="_blank">Security</a></p>
                            </div>
                        )
                    }                    

                    return (
                        // <div style={{padding: "10px"}}>
                        <div style={{padding: "5px"}}>
                            {(!(isSettingStatus)) && loginComponent()}
                            {((isLoggedStatus) && (isSettingStatus)) && dashboardComponent()}
                            {((isLoggedStatus) && (isSettingStatus) && (ischeckboxType == "authorAI")) && 
                                <>
                                    {authorAIDashboardComponents()}
                                    {pre_post_textarea()}
                                </>
                            
                            }
                            {footerPart()}                            
                            <style>{${styleSection}}</style>
                        </div>
                    )
                });
                <AuthorAIComponent 
                    conversation={conversation}
                    appSettings={appSettings}
                />     
    
    }
        
    `,
    context: 'smartbar-card',
    resource: 'conversation',
    meta: {
        displayName: "Sample AuthorAI",
        icon: "earth",
        state: "open"
    }
}